<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>利用哈希表求解序列中两数之和</title>
      <link href="/2023/08/30/%E5%88%A9%E7%94%A8%E5%93%88%E5%B8%8C%E8%A1%A8%E6%B1%82%E8%A7%A3%E5%BA%8F%E5%88%97%E4%B8%AD%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2023/08/30/%E5%88%A9%E7%94%A8%E5%93%88%E5%B8%8C%E8%A1%A8%E6%B1%82%E8%A7%A3%E5%BA%8F%E5%88%97%E4%B8%AD%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="LEETCODE第一题"><a href="#LEETCODE第一题" class="headerlink" title="LEETCODE第一题"></a>LEETCODE第一题</h1><p>很尴尬，第一题就不会，理解了好久。</p><p>题目描述为：</p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p><em><strong>解法一：暴力枚举</strong></em></p><p>利用两个for循环</p><p>时间复杂度为0(N^2):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em><strong>解法二：利用哈希表</strong></em></p><p>思路及算法</p><p>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p><p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N)O(N) 降低到 O(1)O(1)O(1)。</p><p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p><p>时间复杂度为0(N)， 其中N是数组中元素数量:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">               <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">               <span class="keyword">if</span> (it != m.<span class="built_in">end</span>())</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">return</span> &#123;(*it).second, i&#125;;</span><br><span class="line">               &#125; </span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LEETCODE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11新特性之for循环(基于范围的循环)</title>
      <link href="/2023/08/30/C-11%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF-%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84%E5%BE%AA%E7%8E%AF/"/>
      <url>/2023/08/30/C-11%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF-%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="For基于范围的循环"><a href="#For基于范围的循环" class="headerlink" title="For基于范围的循环"></a>For基于范围的循环</h1><p>C++ 11标准之前（C++ 98&#x2F;03 标准），如果要用 for 循环语句遍历一个数组或者容器，只能套用如下结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式 <span class="number">1</span>; 表达式 <span class="number">2</span>; 表达式 <span class="number">3</span>)&#123;</span><br><span class="line">  <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，下面程序演示了用上述结构遍历数组和容器的具体实现过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    <span class="type">char</span> arc[] = <span class="string">&quot;www.crazymorty.com&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//for循环遍历普通数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(arc); i++) &#123;</span><br><span class="line">        cout &lt;&lt; arc[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt;<span class="built_in">v</span>(arc,arc+<span class="number">18</span>);</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt;::iterator it;</span><br><span class="line">    <span class="comment">//for循环遍历 vector 容器</span></span><br><span class="line">    <span class="keyword">for</span> (it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        cout &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.crazymorty.com</span><br><span class="line">www.crazymorty.com</span><br></pre></td></tr></table></figure><p>[^其中vector是STL标准库提供的序列式容器]: </p><p>而 C++ 11 标准中，除了可以沿用前面介绍的用法外，还为 for 循环添加了一种全新的语法格式，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)&#123;</span><br><span class="line">  <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，两个参数各自的含义如下：</p><ul><li>declaration：表示此处要定义一个变量，该变量的类型为要遍历序列中存储元素的类型。需要注意的是，C++ 11 标准中，declaration参数处定义的变量类型可以用 auto 关键字表示，该关键字可以使编译器自行推导该变量的数据类型。</li><li>expression：表示要遍历的序列，常见的可以为事先定义好的普通数组或者容器，还可以是用 {} 大括号初始化的序列。</li></ul><p>可以看到，同 C++ 98&#x2F;03 中 for 循环的语法格式相比较，此格式并没有明确限定 for 循环的遍历范围，这是它们最大的区别，即旧格式的 for 循环可以指定循环的范围，而 C++11 标准增加的 for 循环，只会逐个遍历 expression 参数处指定序列中的每个元素。</p><p>下面程序演示了如何用C++11标准中的for循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    <span class="type">char</span> arc[] = <span class="string">&quot;www.crazymorty.com&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//for循环遍历普通数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> ch : arc)&#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt;<span class="built_in">v</span>(arc,arc+<span class="number">18</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : v)&#123;</span><br><span class="line">        cout &lt;&lt; x;</span><br><span class="line">    &#125;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.crazymorty.com !</span><br><span class="line">www.crazymorty.com!</span><br></pre></td></tr></table></figure><p>其中注意两点：</p><ul><li>程序中定义了auto类型的x，当编译器编译程序时，会自动根据vector容器中定义的类型推导出x所需要的类型为char。</li><li>观察输出结果，其中第一行输出的字符串和 “!” 之间还输出有一个空格，这是因为新格式的 for 循环在遍历字符串序列时，不只是遍历到最后一个字符，还会遍历位于该字符串末尾的 ‘\0’（字符串的结束标志）。之所以第二行输出的字符串和 “!” 之间没有空格，是因为  v  容器中没有存储 ‘\0’。</li></ul><p>在使用新语法格式的 for 循环遍历某个序列时，如果需要遍历的同时修改序列中元素的值，实现方案是在 declaration 参数处定义引用形式的变量。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arc[] = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt;<span class="built_in">v</span>(arc, arc + <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//for循环遍历并修改容器中各个字符的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : v) &#123;</span><br><span class="line">        ch++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for循环遍历输出容器中各个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : v) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdef</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中进行文件的IO操作</title>
      <link href="/2023/08/07/C-%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84IO%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/08/07/C-%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84IO%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>C++中通过对文件的操作保存文本或二进制数据。</p><p>对文件操作需要包含头文件**<fstream>**</p><h1 id="1-文本文件"><a href="#1-文本文件" class="headerlink" title="1.文本文件"></a>1.文本文件</h1><h2 id="1-写文件"><a href="#1-写文件" class="headerlink" title="1.写文件"></a>1.写文件</h2><p>其操作步骤如下：</p><p>1.包含头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.创建流对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofstream ofs;</span><br></pre></td></tr></table></figure><p>3.打开文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;文件路径&quot;</span>, 文件打开方式);</span><br></pre></td></tr></table></figure><p>4.写数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofs &lt;&lt; <span class="string">&quot;写入的数据&quot;</span>;</span><br></pre></td></tr></table></figure><p>5.关闭文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofs.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><p>第三步中文件的打开方式有以下几种：</p><table><thead><tr><th align="center">打开方式</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">ios::in</td><td align="center">读文件</td></tr><tr><td align="center">ios::out</td><td align="center">写文件</td></tr><tr><td align="center">ios::ate</td><td align="center">初始位置定义为文件尾</td></tr><tr><td align="center">ios::app</td><td align="center">追加方式写文件</td></tr><tr><td align="center">ios::trunc</td><td align="center">如果文件存在，先删除，再创建</td></tr><tr><td align="center">ios::binary</td><td align="center">二进制方式</td></tr></tbody></table><p>文件打开方式可以多个配合使用，方式间利用 | 操作符隔开。</p><p>例如：用二进制方式写文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ios::out | ios::binary</span><br></pre></td></tr></table></figure><h2 id="2-读文件"><a href="#2-读文件" class="headerlink" title="2.读文件"></a>2.读文件</h2><p>读文件步骤如下：</p><p>1.包含头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.创建流对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifstream ifs;</span><br></pre></td></tr></table></figure><p>3.打开文件并判断文件是否打开成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifs.open(&quot;文件路径&quot;, 打开方式);</span><br></pre></td></tr></table></figure><p>4.读数据（四种）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式：</span></span><br><span class="line"><span class="type">char</span> a[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(ifs &gt;&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种:</span></span><br><span class="line"><span class="type">char</span> a[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(ifs.<span class="built_in">getline</span>(a, <span class="built_in">sizeof</span>(a)))</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三种：</span></span><br><span class="line">string a;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(ifs, a))</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第四种：</span></span><br><span class="line"><span class="type">char</span> a;</span><br><span class="line"><span class="keyword">while</span>((a = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.关闭文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifs.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><h1 id="2-二进制文件"><a href="#2-二进制文件" class="headerlink" title="2.二进制文件"></a>2.二进制文件</h1><h2 id="1-写文件-1"><a href="#1-写文件-1" class="headerlink" title="1.写文件"></a>1.写文件</h2><p>二进制方式写文件主要利用流对象调用成员函数<strong>write</strong></p><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * buffer, <span class="type">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，字符指针buffer指向内存中的一段存储空间，len是读写的字节数。</p><p>示例代码：</p><p>1.包含一个Person类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.测试函数test()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建输出流对象同时打开文件</span></span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;Person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">    Person p = &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">    <span class="comment">//写文件</span></span><br><span class="line">    ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.主函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-读文件-1"><a href="#2-读文件-1" class="headerlink" title="2.读文件"></a>2.读文件</h2><p>二进制方式读文件主要利用流对象调用成员函数<strong>read</strong></p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间，len是读写的字节数。</p><p>示例代码：</p><p>1.包含一个Person类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.测试函数test()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建输入流对象同时打开文件</span></span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;Person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Person p = &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">    <span class="comment">//读文件</span></span><br><span class="line">    ifs.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.主函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++深拷贝解决堆区内存重复释放</title>
      <link href="/2023/08/07/C-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%A7%A3%E5%86%B3%E5%A0%86%E5%8C%BA%E5%86%85%E5%AD%98%E9%87%8D%E5%A4%8D%E9%87%8A%E6%94%BE/"/>
      <url>/2023/08/07/C-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%A7%A3%E5%86%B3%E5%A0%86%E5%8C%BA%E5%86%85%E5%AD%98%E9%87%8D%E5%A4%8D%E9%87%8A%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="C-深拷贝、浅拷贝"><a href="#C-深拷贝、浅拷贝" class="headerlink" title="C++深拷贝、浅拷贝"></a>C++深拷贝、浅拷贝</h1><h2 id="1-C-内存分区"><a href="#1-C-内存分区" class="headerlink" title="1.C++内存分区"></a>1.C++内存分区</h2><p>在C++程序执行时，内存大致划为四大区域：</p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理。</li><li>全局区：存放全局变量、静态变量以及常量。</li><li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。</li><li>堆区：由程序员手动开辟与释放，否则程序结束时由操作系统回收内存。</li></ul><p>其中，C++在运行前分为全局区与代码区。代码区的特点是共享和只读，常量区中存放const修饰的全局常量和字符串常量。</p><p>C++程序运行后分为栈区与堆区，其中主要利用<strong>new</strong>在堆区开辟内存。</p><p><em><strong>示例代码：</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">//在a的地址开辟一个数组包含10个元素的内存</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span>[] arr; <span class="comment">//程序运行结束手动释放这个数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-拷贝构造函数"><a href="#2-拷贝构造函数" class="headerlink" title="2.拷贝构造函数"></a>2.拷贝构造函数</h2><p>通常，拷贝函数调用时机有三种情况：</p><ul><li>使用一个创建完毕的对象来初始化另一个同一个类里的对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部函数</li></ul><p><strong>如果在类中有开辟堆区的属性，一定要自己提供拷贝构造函数进行深拷贝的操作，防止浅拷贝带来的问题，并且在析构函数中释放堆区内存。</strong></p><p><em><strong>示例代码：</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> height)  <span class="comment">//构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) <span class="comment">//拷贝函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//深拷贝，对height重新开辟一堆内存,进行拷贝操作</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = p.age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.height);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;   <span class="comment">//析构函数释放开辟的堆区内存</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;height != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span>* height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我在利用hexo建立个人博客碰见的各类问题</title>
      <link href="/2023/08/06/%E5%85%B3%E4%BA%8E%E6%88%91%E5%9C%A8%E5%88%A9%E7%94%A8hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%A2%B0%E8%A7%81%E7%9A%84%E5%90%84%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/06/%E5%85%B3%E4%BA%8E%E6%88%91%E5%9C%A8%E5%88%A9%E7%94%A8hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%A2%B0%E8%A7%81%E7%9A%84%E5%90%84%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="创建中途会遇到各类问题：（缓慢更新中）"><a href="#创建中途会遇到各类问题：（缓慢更新中）" class="headerlink" title="创建中途会遇到各类问题：（缓慢更新中）"></a>创建中途会遇到各类问题：（缓慢更新中）</h1><h2 id="1-Hexo本地部署后，实际网站并没有进行相应的改变？"><a href="#1-Hexo本地部署后，实际网站并没有进行相应的改变？" class="headerlink" title="1. Hexo本地部署后，实际网站并没有进行相应的改变？"></a>1. Hexo本地部署后，实际网站并没有进行相应的改变？</h2><p><strong>这里有很多因素：</strong></p><h4 id="1-可能是因为在博客根目录的-config-yml-文件下，未设置你的URL"><a href="#1-可能是因为在博客根目录的-config-yml-文件下，未设置你的URL" class="headerlink" title="1. 可能是因为在博客根目录的_config.yml 文件下，未设置你的URL:"></a>1. 可能是因为在博客根目录的<u>_config.yml</u> 文件下，未设置你的URL:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url: https://xxx.github.io</span><br></pre></td></tr></table></figure><h4 id="2-在你的github中对应的网址仓库，没有进行对域名的绑定"><a href="#2-在你的github中对应的网址仓库，没有进行对域名的绑定" class="headerlink" title="2. 在你的github中对应的网址仓库，没有进行对域名的绑定:"></a>2. 在你的github中对应的网址仓库，没有进行对域名的绑定:</h4><center>    <img src="https://babyblue916.oss-cn-shanghai.aliyuncs.com/img/1-16913158079909.png" alt="img" style="zoom:33%;" /><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello world</title>
      <link href="/2023/08/06/hello-world/"/>
      <url>/2023/08/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p><strong>欢迎来到 <a href="https://crazymorty.com/">CrazyMorty</a>的个人博客! 这是我的第一篇博客！</strong> </p><p><strong>如果你对我的博客有更好的建议或者请求，请访问我的<a href="https://github.com/babyblue916">GitHub</a>，或者添加我的微信:</strong></p><img src="https://babyblue916.oss-cn-shanghai.aliyuncs.com/img/wechat.png" alt="img" style="zoom:33%;" /><h2 id="1-创建个人博客的初衷"><a href="#1-创建个人博客的初衷" class="headerlink" title="1.创建个人博客的初衷"></a>1.创建个人博客的初衷</h2><p>一次机缘巧合下，在我大二升大三的暑假时作为嵌入式开发实习生的身份进入了一家互联网公司进行为期两个月的实习，可以说是非常幸运，能够接触到互联网行业内的各种大佬。我要感谢我的项目经理，也是他启发了我制作个人技术博客的想法，也希望他能在这个行业中步步高升，达成自己的目标和梦想！</p><h2 id="2-对个人技术博客的要求"><a href="#2-对个人技术博客的要求" class="headerlink" title="2.对个人技术博客的要求"></a>2.对个人技术博客的要求</h2><p>希望能够通过个人博客记录下自己学习的笔记，记录同时希望能够认识各位博客大佬们，认识与总结他们的各类优秀博客文章来提升自己。</p><h2 id="3-未来目标与规划"><a href="#3-未来目标与规划" class="headerlink" title="3.未来目标与规划"></a>3.未来目标与规划</h2><p>目前未来的目标是出国留学，小目标是先考出雅思，提升自己的gpa绩点与各类计算机技能。</p><p>嗯，目前就是这些打算，欢迎添加我的微信和我进行<strong>愉♂快的讨论</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
