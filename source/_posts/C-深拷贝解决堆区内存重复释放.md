---
title: C++深拷贝解决堆区内存重复释放
date: 2023-08-07 16:37:23
tags: C++
---

# C++深拷贝、浅拷贝



## 1.C++内存分区

在C++程序执行时，内存大致划为四大区域：

- 代码区：存放函数体的二进制代码，由操作系统进行管理。
- 全局区：存放全局变量、静态变量以及常量。
- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。
- 堆区：由程序员手动开辟与释放，否则程序结束时由操作系统回收内存。

其中，C++在运行前分为全局区与代码区。代码区的特点是共享和只读，常量区中存放const修饰的全局常量和字符串常量。

C++程序运行后分为栈区与堆区，其中主要利用**new**在堆区开辟内存。

***示例代码：***

```c++
int main()
{
    int *arr = new int[10]; //在a的地址开辟一个数组包含10个元素的内存
    ...
    delete[] arr; //程序运行结束手动释放这个数组
}

```



## 2.拷贝构造函数

通常，拷贝函数调用时机有三种情况：

- 使用一个创建完毕的对象来初始化另一个同一个类里的对象
- 值传递的方式给函数参数传值
- 以值方式返回局部函数

**如果在类中有开辟堆区的属性，一定要自己提供拷贝构造函数进行深拷贝的操作，防止浅拷贝带来的问题，并且在析构函数中释放堆区内存。**

***示例代码：***

```c++
class Person
{
 public:
    Person(int age, int height)  //构造函数
    {
        this->age = age;
        this->height = new int(height);
    }
    Person(const Person& p) //拷贝函数
    {
        //深拷贝，对height重新开辟一堆内存,进行拷贝操作
        this->age = p.age;
        this->height = new int(*p.height);
    }
    ~Person()
    {   //析构函数释放开辟的堆区内存
        if(this->height != NULL)
        {
            delete this->height;
        }
    }
    int age;
    int* height;
};
```

